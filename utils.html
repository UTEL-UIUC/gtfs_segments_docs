<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>gtfs_segments.utils API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>gtfs_segments.utils</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import os
import shutil
import requests
import traceback
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
## Plot style
plt.style.use(&#39;ggplot&#39;)
from scipy.stats import gaussian_kde
from shapely.geometry import Point

def plot_hist(df,save_fig = False,show_mean = False,**kwargs):
    &#34;&#34;&#34;
    It takes a dataframe with two columns, one with the distance between stops and the other with the
    number of traversals between those stops, and plots a weighted histogram of the distances
    
    Args:
      df: The dataframe that contains the data
      save_fig: If True, the figure will be saved to the file_path. Defaults to False
      show_mean: If True, will show the mean of the distribution. Defaults to False
    
    Returns:
      A matplotlib axis
    &#34;&#34;&#34;
    if &#34;max_spacing&#34; not in kwargs.keys():
        max_spacing = 3000
        print(&#34;Using max_spacing = 3000&#34;)
    else:
        max_spacing = kwargs[&#39;max_spacing&#39;]
    if &#34;ax&#34; in kwargs.keys():
        ax = kwargs[&#39;ax&#39;]
    else:
        fig, ax = plt.subplots(figsize=(8,6))
    df = df[df[&#39;distance&#39;] &lt; max_spacing]
    data = np.hstack([np.repeat(x, y) for x, y in zip(df[&#39;distance&#39;], df.traversals)])
    plt.hist(data,range=(0,max_spacing),density = True,bins = int(max_spacing/50),fc=(0, 105/255, 160/255, 0.4),ec = &#34;white&#34;,lw =0.8)
    x = np.arange(0,max_spacing,5)
    plt.plot(x,gaussian_kde(data)(x),lw = 1.5,color=(0, 85/255, 120/255, 1))
    # sns.histplot(data,binwidth=50,stat = &#34;density&#34;,kde=True,ax=ax)
    plt.xlim([0,max_spacing])
    plt.xlabel(&#39;Stop Spacing [m]&#39;)
    plt.ylabel(&#39;Density - Traversal Weighted&#39;)
    plt.title(&#34;Histogram of Spacing&#34;)
    if show_mean:
        plt.axvline(np.mean(data), color=&#39;k&#39;, linestyle=&#39;dashed&#39;, linewidth=2)
        min_ylim, max_ylim = plt.ylim()
        plt.text(np.mean(data)*1.1, max_ylim*0.9, &#39;Mean: {:.0f}&#39;.format(np.mean(data)),fontsize=12)
    if &#34;title&#34; in kwargs.keys():
        plt.title(kwargs[&#39;title&#39;])
    if save_fig == True:
        assert &#34;file_path&#34; in kwargs.keys(), &#34;Please pass in the `file_path`&#34;
        plt.savefig(kwargs[&#39;file_path&#39;], dpi=300)
    plt.show()
    plt.close(fig)
    return ax

def summary_stats(df,export = False,**kwargs):
    &#34;&#34;&#34;
    It takes in a dataframe, and returns a dataframe with summary statistics
    
    Args:
      df: The dataframe that you want to get the summary statistics for.
      export: If True, the summary will be exported to a csv file. Defaults to False
    
    Returns:
      A dataframe with the summary statistics
    &#34;&#34;&#34;
    if &#34;max_spacing&#34; not in kwargs.keys():
        max_spacing = 3000
        print(&#34;Using max_spacing = 3000&#34;)
    else:
        max_spacing = kwargs[&#39;max_spacing&#39;]
    percent_spacing = round(df[df[&#34;distance&#34;] &gt; max_spacing][&#39;traversals&#39;].sum()/df[&#39;traversals&#39;].sum() *100,3)
    df = df[df[&#34;distance&#34;] &lt;= max_spacing]
    stop_weighted_mean = df.groupby([&#39;segment_id&#39;,&#39;distance&#39;]).first().reset_index()[&#34;distance&#34;].mean()
    route_weighted_mean = df.groupby([&#39;route_id&#39;,&#39;segment_id&#39;,&#39;distance&#39;]).first().reset_index()[&#34;distance&#34;].mean()
    weighted_data =  np.hstack([np.repeat(x, y) for x, y in zip(df[&#39;distance&#39;], df.traversals)])
    
    df_dict = {
            &#39;Segment Weighted Mean&#39; : stop_weighted_mean,
            &#39;Route Weighted Mean&#39; : route_weighted_mean,
            &#39;Traversal Weighted Mean&#39;: round(np.mean(weighted_data),3),
            &#39;Traversal Weighted Std&#39;: round(np.mean(weighted_data),3),
            &#39;Traversal Weighted 25 % Quantile&#39;: round(np.quantile(weighted_data,0.25),3),
            &#39;Traversal Weighted 50 % Quantile&#39;: round(np.quantile(weighted_data,0.50),3),
            &#39;Traversal Weighted 75 % Quantile&#39;: round(np.quantile(weighted_data,0.75),3),
            &#39;No of Segments&#39;:int(len(df)),
            &#39;No of Routes&#39;:int(len(df.route_id.unique())),
            &#39;No of Traversals&#39;:int(sum(df.traversals)),  
            &#39;Max Spacing&#39;:int(max_spacing),
            &#39;% Segments w/ spacing &gt; max_spacing&#39;:percent_spacing}
    summary_df = pd.DataFrame([df_dict])
    # df.set_index(summary_df.columns[0],inplace=True)
    if export:
        assert &#34;file_path&#34; in kwargs.keys(), &#34;Please pass in the `file_path`&#34;
        summary_df.to_csv(kwargs[&#39;file_path&#39;],index = False)
        print(&#34;Saved the summary in &#34;+kwargs[&#39;file_path&#39;])
    summary_df = summary_df.T
    return summary_df 
        
def export_segments(df,file_path,output_format, geometry = True):
    &#34;&#34;&#34;
    This function takes a GeoDataFrame of segments, a file path, an output format, and a boolean value
    for whether or not to include the geometry in the output. 
    
    If the output format is GeoJSON, the function will output the GeoDataFrame to a GeoJSON file. 
    
    If the output format is CSV, the function will output the GeoDataFrame to a CSV file. If the
    geometry boolean is set to True, the function will output the CSV file with the geometry column. If
    the geometry boolean is set to False, the function will output the CSV file without the geometry
    column. 
    
    The function will also add additional columns to the CSV file, including the start and end points of
    the segments, the start and end longitude and latitude of the segments, and the distance of the
    segments. 
    
    The function will also add a column to the CSV file that indicates the number of times the segment
    was traversed.
    
    Args:
      df: the dataframe containing the segments
      file_path: The path to the file you want to export to.
      output_format: geojson or csv
      geometry: If True, the output will include the geometry of the segments. If False, the output will
    only include the start and end points of the segments. Defaults to True
    &#34;&#34;&#34;
    ## Output to GeoJSON
    if output_format == &#39;geojson&#39;:
        df.to_file(file_path+&#39;.json&#39;, driver=&#34;GeoJSON&#34;)
    elif output_format == &#39;csv&#39;:
        s_df = df[[&#39;route_id&#39;,&#39;segment_id&#39;,&#39;stop_id1&#39;,&#39;stop_id2&#39;,&#39;distance&#39;,&#39;traversals&#39;,&#39;geometry&#39;]].copy()
        geom_list =  s_df.geometry.apply(lambda g: np.array(g.coords))
        s_df[&#39;start_point&#39;] = [Point(g[0]).wkt for g in geom_list]
        s_df[&#39;end_point&#39;] = [Point(g[-1]).wkt for g in geom_list]
        s_df[&#39;start_lon&#39;] = [g[0][0] for g in geom_list]
        s_df[&#39;start_lat&#39;] = [g[0][1] for g in geom_list]
        s_df[&#39;end_lon&#39;] = [g[-1][0] for g in geom_list]
        s_df[&#39;end_lat&#39;] = [g[-1][1] for g in geom_list]
        sg_df = s_df[[&#39;route_id&#39;,&#39;segment_id&#39;,&#39;stop_id1&#39;,&#39;stop_id2&#39;,&#39;distance&#39;,&#39;traversals&#39;,&#39;start_point&#39;,&#39;end_point&#39;,&#39;geometry&#39;]]
        if geometry == True:
            ## Output With LS
            sg_df.to_csv(file_path+&#39;.csv&#39;,index = False)
        else:
            d_df = s_df[[&#39;route_id&#39;,&#39;segment_id&#39;,&#39;stop_id1&#39;,&#39;stop_id2&#39;,&#39;start_lat&#39;,&#39;start_lon&#39;,&#39;end_lat&#39;,&#39;end_lon&#39;,&#39;distance&#39;,&#39;traversals&#39;]]
            ## Output without LS
            d_df.to_csv(file_path+&#39;.csv&#39;,index = False)


def process(pipeline_gtfs,row,max_spacing):
    &#34;&#34;&#34;
    It takes a pipeline, a row from the sources_df, and a max_spacing, and returns the output of the
    pipeline
    
    Args:
      pipeline_gtfs: This is the function that will be used to process the GTFS data.
      row: This is a row in the sources_df dataframe. It contains the name of the provider, the url to
    the gtfs file, and the bounding box of the area that the gtfs file covers.
      max_spacing: Maximum Allowed Spacing between two consecutive stops.
    
    Returns:
      The return value is a tuple of the form (filename,folder_path,df)
    &#34;&#34;&#34;
    filename = row[&#39;provider&#39;]
    url = row[&#39;urls.latest&#39;]
    bounds = [[row[&#39;minimum_longitude&#39;],row[&#39;minimum_latitude&#39;]],[row[&#39;maximum_longitude&#39;],row[&#39;maximum_latitude&#39;]]]
    print(filename)
    try:
        return pipeline_gtfs(filename,url,bounds,max_spacing)
    except:
        traceback.print_exc()
        folder_path  = os.path.join(&#39;output_files&#39;,filename)
        return failed_pipeline(&#34;Failed for &#34;,filename,folder_path)

def failed_pipeline(message,filename,folder_path):
    &#34;&#34;&#34;
    &#34;If the folder path exists, delete it and return the failure message.&#34;
    
    Args:
      message: The message to be returned
      filename: The name of the file that is being processed
      folder_path: The path to the folder where the file is located
    
    Returns:
      a string that is the concatenation of the message and the filename, indicating failure
    &#34;&#34;&#34;

    if os.path.exists(folder_path):
        shutil.rmtree(folder_path)
    return message + filename

def download_write_file(url,folder_path):
    &#34;&#34;&#34;
    It takes a URL and a folder path as input, creates a new folder if it does not exist, downloads the
    file from the URL, and writes the file to the folder path
    
    Args:
      url: The URL of the GTFS file you want to download
      folder_path: The path to the folder where you want to save the GTFS file.
    
    Returns:
      The location of the file that was downloaded.
    &#34;&#34;&#34;
    # Create a new directory if it does not exist
    if not os.path.exists(folder_path):
        os.makedirs(folder_path)
    ## Download file from URL
    r = requests.get(url, allow_redirects=True)
    gtfs_file_loc = os.path.join(folder_path,&#34;gtfs.zip&#34;)
    
    ## Write file locally
    file = open(gtfs_file_loc, &#34;wb&#34;)
    file.write(r.content)
    file.close()
    return gtfs_file_loc</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="gtfs_segments.utils.download_write_file"><code class="name flex">
<span>def <span class="ident">download_write_file</span></span>(<span>url, folder_path)</span>
</code></dt>
<dd>
<div class="desc"><p>It takes a URL and a folder path as input, creates a new folder if it does not exist, downloads the
file from the URL, and writes the file to the folder path</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>url</code></strong></dt>
<dd>The URL of the GTFS file you want to download</dd>
<dt><strong><code>folder_path</code></strong></dt>
<dd>The path to the folder where you want to save the GTFS file.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The location of the file that was downloaded.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def download_write_file(url,folder_path):
    &#34;&#34;&#34;
    It takes a URL and a folder path as input, creates a new folder if it does not exist, downloads the
    file from the URL, and writes the file to the folder path
    
    Args:
      url: The URL of the GTFS file you want to download
      folder_path: The path to the folder where you want to save the GTFS file.
    
    Returns:
      The location of the file that was downloaded.
    &#34;&#34;&#34;
    # Create a new directory if it does not exist
    if not os.path.exists(folder_path):
        os.makedirs(folder_path)
    ## Download file from URL
    r = requests.get(url, allow_redirects=True)
    gtfs_file_loc = os.path.join(folder_path,&#34;gtfs.zip&#34;)
    
    ## Write file locally
    file = open(gtfs_file_loc, &#34;wb&#34;)
    file.write(r.content)
    file.close()
    return gtfs_file_loc</code></pre>
</details>
</dd>
<dt id="gtfs_segments.utils.export_segments"><code class="name flex">
<span>def <span class="ident">export_segments</span></span>(<span>df, file_path, output_format, geometry=True)</span>
</code></dt>
<dd>
<div class="desc"><p>This function takes a GeoDataFrame of segments, a file path, an output format, and a boolean value
for whether or not to include the geometry in the output. </p>
<p>If the output format is GeoJSON, the function will output the GeoDataFrame to a GeoJSON file. </p>
<p>If the output format is CSV, the function will output the GeoDataFrame to a CSV file. If the
geometry boolean is set to True, the function will output the CSV file with the geometry column. If
the geometry boolean is set to False, the function will output the CSV file without the geometry
column. </p>
<p>The function will also add additional columns to the CSV file, including the start and end points of
the segments, the start and end longitude and latitude of the segments, and the distance of the
segments. </p>
<p>The function will also add a column to the CSV file that indicates the number of times the segment
was traversed.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>df</code></strong></dt>
<dd>the dataframe containing the segments</dd>
<dt><strong><code>file_path</code></strong></dt>
<dd>The path to the file you want to export to.</dd>
<dt><strong><code>output_format</code></strong></dt>
<dd>geojson or csv</dd>
<dt><strong><code>geometry</code></strong></dt>
<dd>If True, the output will include the geometry of the segments. If False, the output will</dd>
</dl>
<p>only include the start and end points of the segments. Defaults to True</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export_segments(df,file_path,output_format, geometry = True):
    &#34;&#34;&#34;
    This function takes a GeoDataFrame of segments, a file path, an output format, and a boolean value
    for whether or not to include the geometry in the output. 
    
    If the output format is GeoJSON, the function will output the GeoDataFrame to a GeoJSON file. 
    
    If the output format is CSV, the function will output the GeoDataFrame to a CSV file. If the
    geometry boolean is set to True, the function will output the CSV file with the geometry column. If
    the geometry boolean is set to False, the function will output the CSV file without the geometry
    column. 
    
    The function will also add additional columns to the CSV file, including the start and end points of
    the segments, the start and end longitude and latitude of the segments, and the distance of the
    segments. 
    
    The function will also add a column to the CSV file that indicates the number of times the segment
    was traversed.
    
    Args:
      df: the dataframe containing the segments
      file_path: The path to the file you want to export to.
      output_format: geojson or csv
      geometry: If True, the output will include the geometry of the segments. If False, the output will
    only include the start and end points of the segments. Defaults to True
    &#34;&#34;&#34;
    ## Output to GeoJSON
    if output_format == &#39;geojson&#39;:
        df.to_file(file_path+&#39;.json&#39;, driver=&#34;GeoJSON&#34;)
    elif output_format == &#39;csv&#39;:
        s_df = df[[&#39;route_id&#39;,&#39;segment_id&#39;,&#39;stop_id1&#39;,&#39;stop_id2&#39;,&#39;distance&#39;,&#39;traversals&#39;,&#39;geometry&#39;]].copy()
        geom_list =  s_df.geometry.apply(lambda g: np.array(g.coords))
        s_df[&#39;start_point&#39;] = [Point(g[0]).wkt for g in geom_list]
        s_df[&#39;end_point&#39;] = [Point(g[-1]).wkt for g in geom_list]
        s_df[&#39;start_lon&#39;] = [g[0][0] for g in geom_list]
        s_df[&#39;start_lat&#39;] = [g[0][1] for g in geom_list]
        s_df[&#39;end_lon&#39;] = [g[-1][0] for g in geom_list]
        s_df[&#39;end_lat&#39;] = [g[-1][1] for g in geom_list]
        sg_df = s_df[[&#39;route_id&#39;,&#39;segment_id&#39;,&#39;stop_id1&#39;,&#39;stop_id2&#39;,&#39;distance&#39;,&#39;traversals&#39;,&#39;start_point&#39;,&#39;end_point&#39;,&#39;geometry&#39;]]
        if geometry == True:
            ## Output With LS
            sg_df.to_csv(file_path+&#39;.csv&#39;,index = False)
        else:
            d_df = s_df[[&#39;route_id&#39;,&#39;segment_id&#39;,&#39;stop_id1&#39;,&#39;stop_id2&#39;,&#39;start_lat&#39;,&#39;start_lon&#39;,&#39;end_lat&#39;,&#39;end_lon&#39;,&#39;distance&#39;,&#39;traversals&#39;]]
            ## Output without LS
            d_df.to_csv(file_path+&#39;.csv&#39;,index = False)</code></pre>
</details>
</dd>
<dt id="gtfs_segments.utils.failed_pipeline"><code class="name flex">
<span>def <span class="ident">failed_pipeline</span></span>(<span>message, filename, folder_path)</span>
</code></dt>
<dd>
<div class="desc"><p>"If the folder path exists, delete it and return the failure message."</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>message</code></strong></dt>
<dd>The message to be returned</dd>
<dt><strong><code>filename</code></strong></dt>
<dd>The name of the file that is being processed</dd>
<dt><strong><code>folder_path</code></strong></dt>
<dd>The path to the folder where the file is located</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>a string that is the concatenation of the message and the filename, indicating failure</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def failed_pipeline(message,filename,folder_path):
    &#34;&#34;&#34;
    &#34;If the folder path exists, delete it and return the failure message.&#34;
    
    Args:
      message: The message to be returned
      filename: The name of the file that is being processed
      folder_path: The path to the folder where the file is located
    
    Returns:
      a string that is the concatenation of the message and the filename, indicating failure
    &#34;&#34;&#34;

    if os.path.exists(folder_path):
        shutil.rmtree(folder_path)
    return message + filename</code></pre>
</details>
</dd>
<dt id="gtfs_segments.utils.plot_hist"><code class="name flex">
<span>def <span class="ident">plot_hist</span></span>(<span>df, save_fig=False, show_mean=False, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>It takes a dataframe with two columns, one with the distance between stops and the other with the
number of traversals between those stops, and plots a weighted histogram of the distances</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>df</code></strong></dt>
<dd>The dataframe that contains the data</dd>
<dt><strong><code>save_fig</code></strong></dt>
<dd>If True, the figure will be saved to the file_path. Defaults to False</dd>
<dt><strong><code>show_mean</code></strong></dt>
<dd>If True, will show the mean of the distribution. Defaults to False</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A matplotlib axis</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_hist(df,save_fig = False,show_mean = False,**kwargs):
    &#34;&#34;&#34;
    It takes a dataframe with two columns, one with the distance between stops and the other with the
    number of traversals between those stops, and plots a weighted histogram of the distances
    
    Args:
      df: The dataframe that contains the data
      save_fig: If True, the figure will be saved to the file_path. Defaults to False
      show_mean: If True, will show the mean of the distribution. Defaults to False
    
    Returns:
      A matplotlib axis
    &#34;&#34;&#34;
    if &#34;max_spacing&#34; not in kwargs.keys():
        max_spacing = 3000
        print(&#34;Using max_spacing = 3000&#34;)
    else:
        max_spacing = kwargs[&#39;max_spacing&#39;]
    if &#34;ax&#34; in kwargs.keys():
        ax = kwargs[&#39;ax&#39;]
    else:
        fig, ax = plt.subplots(figsize=(8,6))
    df = df[df[&#39;distance&#39;] &lt; max_spacing]
    data = np.hstack([np.repeat(x, y) for x, y in zip(df[&#39;distance&#39;], df.traversals)])
    plt.hist(data,range=(0,max_spacing),density = True,bins = int(max_spacing/50),fc=(0, 105/255, 160/255, 0.4),ec = &#34;white&#34;,lw =0.8)
    x = np.arange(0,max_spacing,5)
    plt.plot(x,gaussian_kde(data)(x),lw = 1.5,color=(0, 85/255, 120/255, 1))
    # sns.histplot(data,binwidth=50,stat = &#34;density&#34;,kde=True,ax=ax)
    plt.xlim([0,max_spacing])
    plt.xlabel(&#39;Stop Spacing [m]&#39;)
    plt.ylabel(&#39;Density - Traversal Weighted&#39;)
    plt.title(&#34;Histogram of Spacing&#34;)
    if show_mean:
        plt.axvline(np.mean(data), color=&#39;k&#39;, linestyle=&#39;dashed&#39;, linewidth=2)
        min_ylim, max_ylim = plt.ylim()
        plt.text(np.mean(data)*1.1, max_ylim*0.9, &#39;Mean: {:.0f}&#39;.format(np.mean(data)),fontsize=12)
    if &#34;title&#34; in kwargs.keys():
        plt.title(kwargs[&#39;title&#39;])
    if save_fig == True:
        assert &#34;file_path&#34; in kwargs.keys(), &#34;Please pass in the `file_path`&#34;
        plt.savefig(kwargs[&#39;file_path&#39;], dpi=300)
    plt.show()
    plt.close(fig)
    return ax</code></pre>
</details>
</dd>
<dt id="gtfs_segments.utils.process"><code class="name flex">
<span>def <span class="ident">process</span></span>(<span>pipeline_gtfs, row, max_spacing)</span>
</code></dt>
<dd>
<div class="desc"><p>It takes a pipeline, a row from the sources_df, and a max_spacing, and returns the output of the
pipeline</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>pipeline_gtfs</code></strong></dt>
<dd>This is the function that will be used to process the GTFS data.</dd>
<dt><strong><code>row</code></strong></dt>
<dd>This is a row in the sources_df dataframe. It contains the name of the provider, the url to</dd>
</dl>
<p>the gtfs file, and the bounding box of the area that the gtfs file covers.
max_spacing: Maximum Allowed Spacing between two consecutive stops.</p>
<h2 id="returns">Returns</h2>
<p>The return value is a tuple of the form (filename,folder_path,df)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process(pipeline_gtfs,row,max_spacing):
    &#34;&#34;&#34;
    It takes a pipeline, a row from the sources_df, and a max_spacing, and returns the output of the
    pipeline
    
    Args:
      pipeline_gtfs: This is the function that will be used to process the GTFS data.
      row: This is a row in the sources_df dataframe. It contains the name of the provider, the url to
    the gtfs file, and the bounding box of the area that the gtfs file covers.
      max_spacing: Maximum Allowed Spacing between two consecutive stops.
    
    Returns:
      The return value is a tuple of the form (filename,folder_path,df)
    &#34;&#34;&#34;
    filename = row[&#39;provider&#39;]
    url = row[&#39;urls.latest&#39;]
    bounds = [[row[&#39;minimum_longitude&#39;],row[&#39;minimum_latitude&#39;]],[row[&#39;maximum_longitude&#39;],row[&#39;maximum_latitude&#39;]]]
    print(filename)
    try:
        return pipeline_gtfs(filename,url,bounds,max_spacing)
    except:
        traceback.print_exc()
        folder_path  = os.path.join(&#39;output_files&#39;,filename)
        return failed_pipeline(&#34;Failed for &#34;,filename,folder_path)</code></pre>
</details>
</dd>
<dt id="gtfs_segments.utils.summary_stats"><code class="name flex">
<span>def <span class="ident">summary_stats</span></span>(<span>df, export=False, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>It takes in a dataframe, and returns a dataframe with summary statistics</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>df</code></strong></dt>
<dd>The dataframe that you want to get the summary statistics for.</dd>
<dt><strong><code>export</code></strong></dt>
<dd>If True, the summary will be exported to a csv file. Defaults to False</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A dataframe with the summary statistics</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def summary_stats(df,export = False,**kwargs):
    &#34;&#34;&#34;
    It takes in a dataframe, and returns a dataframe with summary statistics
    
    Args:
      df: The dataframe that you want to get the summary statistics for.
      export: If True, the summary will be exported to a csv file. Defaults to False
    
    Returns:
      A dataframe with the summary statistics
    &#34;&#34;&#34;
    if &#34;max_spacing&#34; not in kwargs.keys():
        max_spacing = 3000
        print(&#34;Using max_spacing = 3000&#34;)
    else:
        max_spacing = kwargs[&#39;max_spacing&#39;]
    percent_spacing = round(df[df[&#34;distance&#34;] &gt; max_spacing][&#39;traversals&#39;].sum()/df[&#39;traversals&#39;].sum() *100,3)
    df = df[df[&#34;distance&#34;] &lt;= max_spacing]
    stop_weighted_mean = df.groupby([&#39;segment_id&#39;,&#39;distance&#39;]).first().reset_index()[&#34;distance&#34;].mean()
    route_weighted_mean = df.groupby([&#39;route_id&#39;,&#39;segment_id&#39;,&#39;distance&#39;]).first().reset_index()[&#34;distance&#34;].mean()
    weighted_data =  np.hstack([np.repeat(x, y) for x, y in zip(df[&#39;distance&#39;], df.traversals)])
    
    df_dict = {
            &#39;Segment Weighted Mean&#39; : stop_weighted_mean,
            &#39;Route Weighted Mean&#39; : route_weighted_mean,
            &#39;Traversal Weighted Mean&#39;: round(np.mean(weighted_data),3),
            &#39;Traversal Weighted Std&#39;: round(np.mean(weighted_data),3),
            &#39;Traversal Weighted 25 % Quantile&#39;: round(np.quantile(weighted_data,0.25),3),
            &#39;Traversal Weighted 50 % Quantile&#39;: round(np.quantile(weighted_data,0.50),3),
            &#39;Traversal Weighted 75 % Quantile&#39;: round(np.quantile(weighted_data,0.75),3),
            &#39;No of Segments&#39;:int(len(df)),
            &#39;No of Routes&#39;:int(len(df.route_id.unique())),
            &#39;No of Traversals&#39;:int(sum(df.traversals)),  
            &#39;Max Spacing&#39;:int(max_spacing),
            &#39;% Segments w/ spacing &gt; max_spacing&#39;:percent_spacing}
    summary_df = pd.DataFrame([df_dict])
    # df.set_index(summary_df.columns[0],inplace=True)
    if export:
        assert &#34;file_path&#34; in kwargs.keys(), &#34;Please pass in the `file_path`&#34;
        summary_df.to_csv(kwargs[&#39;file_path&#39;],index = False)
        print(&#34;Saved the summary in &#34;+kwargs[&#39;file_path&#39;])
    summary_df = summary_df.T
    return summary_df </code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="gtfs_segments" href="index.html">gtfs_segments</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="gtfs_segments.utils.download_write_file" href="#gtfs_segments.utils.download_write_file">download_write_file</a></code></li>
<li><code><a title="gtfs_segments.utils.export_segments" href="#gtfs_segments.utils.export_segments">export_segments</a></code></li>
<li><code><a title="gtfs_segments.utils.failed_pipeline" href="#gtfs_segments.utils.failed_pipeline">failed_pipeline</a></code></li>
<li><code><a title="gtfs_segments.utils.plot_hist" href="#gtfs_segments.utils.plot_hist">plot_hist</a></code></li>
<li><code><a title="gtfs_segments.utils.process" href="#gtfs_segments.utils.process">process</a></code></li>
<li><code><a title="gtfs_segments.utils.summary_stats" href="#gtfs_segments.utils.summary_stats">summary_stats</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>